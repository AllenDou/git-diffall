#!/bin/sh -e
# Copyright 2010, Tim Henigan <tim.henigan@gmail.com>
#
# Perform a directory diff between commits in the repository using
# the external diff tool specified in the 'diff.tool' configuration
# option.

USAGE='[--cached] [--copy-back] <commit>{0,2} -- <path>*

    --cached     Compare to the index rather than the working tree
    --copy-back  After invoking diff tool, copies back the files to
                 the working tree, in case they were modified.
                 Implies that the right-hand commit is the working
                 directory.
'

SUBDIRECTORY_OK=1
. "$(git --exec-path)/git-sh-setup"
TOOL_MODE=diff
. "$(git --exec-path)/git-mergetool--lib"

if [ -z $(git config --get diff.tool) ]; then
    echo "Error: The 'diff.tool' configuration option must be set."
    usage
fi

start_dir=$(pwd)

# needed to access tar utility
cdup=$(git rev-parse --show-cdup) &&
cd "$cdup" || {
    echo >&2 "Cannot chdir to $cdup, the toplevel of the working tree"
    exit 1
}

# mktemp is not available on all platforms (missing from msysgit)
# Use a hard-coded tmp dir if it is not available
if [ -z $(which mktemp) ]; then
    tmp=/tmp/git-diffall-tmp
else
    tmp="$(mktemp -d -t tmp.XXXXXX)"
fi
mkdir -p "$tmp"

left=
right=
paths=
path_sep=
compare_staged=
common_ancestor=
left_dir=
right_dir=
copy_back=

while test $# != 0; do
    case "$1" in
    -h|--h|--he|--hel|--help)
        usage
        ;;
    --cached)
        compare_staged=1
        ;;
    --copy-back)
        copy_back=1
        ;;
    --)
        path_sep=1
        ;;
    -*)
        echo Invalid option: "$1"
        usage
        ;;
    *)
        # could be commit, commit range or path limiter
        case "$1" in
        *...*)
            left=${1%...*}
            right=${1#*...}
            common_ancestor=1
            ;;
        *..*)
            left=${1%..*}
            right=${1#*..}
            ;;
        *)
            if [ -n "$path_sep" ]; then
                if [ -z "$paths" ]; then
                    paths=$1
                else
                    paths="$paths $1"
                fi
            elif [ -z "$left" ]; then
                left=$1
            elif [ -z "$right" ]; then
                right=$1
            else
                if [ -z "$paths" ]; then
                    paths=$1
                else
                    paths="$paths $1"
                fi
            fi
            ;;
        esac
        ;;
    esac
    shift
done

# Determine the set of files which changed
if [ -n "$left" ] && [ -n "$right" ]; then
    left_dir="cmt-`git rev-parse --short $left`"
    right_dir="cmt-`git rev-parse --short $right`"

    if [ -n "$compare_staged" ]; then
        usage
    elif [ -n "$common_ancestor" ]; then
        git diff --name-only "$left"..."$right" -- "$paths" > "$tmp"/filelist
    else
        git diff --name-only "$left" "$right" -- "$paths" > "$tmp"/filelist
    fi
elif [ -n "$left" ]; then
    left_dir="cmt-`git rev-parse --short $left`"

    if [ -n "$compare_staged" ]; then
        right_dir="staged"
        git diff --name-only --cached "$left" -- "$paths" > "$tmp"/filelist
    else
        right_dir="working_tree"
        git diff --name-only "$left" -- "$paths" > "$tmp"/filelist
    fi
else
    left_dir="HEAD"

    if [ -n "$compare_staged" ]; then
        right_dir="staged"
        git diff --name-only --cached -- "$paths" > "$tmp"/filelist
    else
        right_dir="working_tree"
        git diff --name-only -- "$paths" > "$tmp"/filelist
    fi
fi

if [ -n "$copy_back" ] &&  [ "$right_dir" != "working_tree" ]; then
    echo "Copying back the files is only possible when comparing commits to working tree"
    exit 1
fi

# Exit immediately if there are no diffs
if [ ! -s "$tmp"/filelist ]; then
    exit 0
fi

# Create the named tmp directories that will hold the files to be compared
mkdir -p "$tmp"/"$left_dir" "$tmp"/"$right_dir"

# Populate the tmp/right_dir directory with the files to be compared
if [ -n "$right" ]; then
    while read name; do
        ls_list=$(git ls-tree $right $name)
        if [ -n "$ls_list" ]; then
            mkdir -p "$tmp"/"$right_dir"/"$(dirname "$name")"
            git show "$right":"$name" > "$tmp"/"$right_dir"/"$name" || true
        fi
    done < "$tmp"/filelist
elif [ -n "$compare_staged" ]; then
    while read name; do
        ls_list=$(git ls-files -- $name)
        if [ -n "$ls_list" ]; then
            mkdir -p "$tmp"/"$right_dir"/"$(dirname "$name")"
            git show :"$name" > "$tmp"/"$right_dir"/"$name"
        fi
    done < "$tmp"/filelist
else
    if [ -n "$(which gnutar)" ]; then
        gnutar --ignore-failed-read -c -T "$tmp"/filelist | (cd "$tmp"/"$right_dir" && gnutar -x)
    else
        tar --ignore-failed-read -c -T "$tmp"/filelist | (cd "$tmp"/"$right_dir" && tar -x)
    fi
fi

# Populate the tmp/left_dir directory with the files to be compared
while read name; do
    if [ -n "$left" ]; then
        ls_list=$(git ls-tree $left $name)
        if [ -n "$ls_list" ]; then
            mkdir -p "$tmp"/"$left_dir"/"$(dirname "$name")"
            git show "$left":"$name" > "$tmp"/"$left_dir"/"$name" || true
        fi
    else
        if [ -n "$compare_staged" ]; then
            ls_list=$(git ls-tree HEAD $name)
            if [ -n "$ls_list" ]; then
                mkdir -p "$tmp"/"$left_dir"/"$(dirname "$name")"
                git show HEAD:"$name" > "$tmp"/"$left_dir"/"$name"
                fi
            else
                mkdir -p "$tmp"/"$left_dir"/"$(dirname "$name")"
                    git show :"$name" > "$tmp"/"$left_dir"/"$name"
        fi
    fi
done < "$tmp"/filelist

# get the required merge tool
# code copied from git-difftool--helper.sh
# TODO: refactor it into a single function
use_ext_cmd () {
	test -n "$GIT_DIFFTOOL_EXTCMD"
}
if ! use_ext_cmd; then
	if test -n "$GIT_DIFF_TOOL"; then
		merge_tool="$GIT_DIFF_TOOL"
	else
		merge_tool="$(get_merge_tool)" || exit
	fi
fi

cd "$tmp"
LOCAL="$left_dir"
REMOTE="$right_dir"
if use_ext_cmd; then
	export BASE
	eval $GIT_DIFFTOOL_EXTCMD '"$LOCAL"' '"$REMOTE"'
else
	run_merge_tool "$merge_tool" false
fi

# On exit, remove the tmp directory
cleanup () {
    cd "$start_dir"
    git_top_dir=$(git rev-parse --show-toplevel)
    #if --copy-back was specified, copy all files back to git root
    # directory, in case they were changed
    if [ -n "$copy_back" ]; then
        find "$tmp/$right_dir" -type f|while read file; do
            cp "$file" "$git_top_dir/${file#$tmp/$right_dir/}"
        done
    fi
    rm -rf "$tmp"
}

trap cleanup EXIT

